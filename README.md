# top-k-frequent-elements
Описание
Дан массив целых чисел nums и целое число k, вернуть k наиболее частых элементов. Вы можете вернуть ответ в любом порядке.

Пример 1:

Входные данные: nums = [1,1,1,2,2,3], k = 2
Выходные данные: [1,2]
Пример 2:

Входные данные: nums = [1], k = 1
Выходные данные: [1]

Ограничения:

1 <= nums.length <= 105
-104 <= nums[i] <= 104
k находится в диапазоне [1, количество уникальных элементов в массиве].
Гарантируется, что ответ будет уникальным.

Продолжение: временная сложность вашего алгоритма должна быть лучше, чем O(n log n), где n — размер массива.

Решения
Решение 1: хэш-таблица + приоритетная очередь (Min Heap)
Мы можем использовать хэш-таблицу для подсчета вхождений каждого элемента, а затем использовать min heap (приоритетную очередь) для хранения самых k частых элементов.

Сначала мы проходим массив один раз, чтобы подсчитать вхождение каждого элемента. Затем мы проходим по хэш-таблице, сохраняя каждый элемент и его количество в min heap. Если размер min heap превышает k, мы извлекаем верхний элемент из кучи, чтобы гарантировать, что размер кучи всегда равен k.

Наконец, мы извлекаем элементы из min heap по одному и помещаем их в результирующий массив.

Сложность по времени составляет O(nlogk) ,а сложность по пространству составляет O(k) . Здесь n — длина массива.
C++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        using pii = pair<int, int>;
        for (int x : nums) {
            ++cnt[x];
        }
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        for (auto& [x, c] : cnt) {
            pq.push({c, x});
            if (pq.size() > k) {
                pq.pop();
            }
        }
        vector<int> ans;
        while (!pq.empty()) {
            ans.push_back(pq.top().second);
            pq.pop();
        }
        return ans;
    }
};